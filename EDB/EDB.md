# EDB

- 오라클 : DB Buffer Cache / 소트 메모리 : PGA
- EDB : Shared Buffer => Buffer Cache / work_mem

## 락 매니저 

- Holder Session / Waiter Session
- 동시성 제어 => 해결 방법 중의 하나가 락임 
    - EDB에 총 8개의 락이 제공됨
    - SELECT 같은 경우 ACCESS SHARE

## 쿼리 옵티마이저

### CBO(Cost Based Optimizer)
- **비용**을 가지고 실행계획 세움!
- Cost : 미리 정의된 파라미터 값과 통계정보를 이용한 숫자
- Cost가 적을 수록 작은 리소스, IO, CPU로 Query가 동작한다고 가정하는 것 
- relpages: 통계 정보 들어감  => relation 
- EXPLAIN : 옵티마이저가 SQL에 대해서 어떻게 실행계획 세우는지 보여주는 명령어 (실제로 SQL을 돌리지 않고, 계획 추정)
- Sequence Scan : 조건절이 없으면 시퀀스 스캔 탐

### 통계 정보 

- 데이터베이스, 테이블, 컬럼
- 결합 인덱스 만들 때 주의 점: 첫번째가 조건절에 항상 자주 오는 것을 넣어야함=> 카디널리티가 좋은 것들 위주로..
- 컬럼의 정렬 상태 : 인덱스 블록 => 인덱스 블록에는 인덱스 키 값이 들어감 => 인덱스 키를 읽어서 테이블 접근 
    - 정렬도가 좋으면 예컨대 인덱스가 4개가 있다고 가정했을 때, 한 번만 탐색해도 됨. 
    - 안좋으면 다 스캔
- RDB : 비트맵 인덱스사용 => 비트맵 인덱스 실행계획 세워짐 ()

### EXPLAIN 

- 실행모드 : Explain Analyze 
- HIT / READ 
- READ : 시간이 많이 걸림 ( 속도 차이 많이 남 ) => 물리적 I/O가 발생이 안되게끔 잘 튜닝하자 =>디스크에서 바로 읽지 않도록 .. .. . => (인덱스가 없다는 의미)
- `INDEX SCAN` =>  `Index Cond` : 인덱스 액세스 조건을 나타냄
- 실행계획 읽는 법 
    - 1. 안쪽부터 읽는다
    - 2. 조인 시에는 OUTER 테이블이 위에 위치한다. 
- `nested loop index` : `Nested Loop Join` (두 테이블을 조인할 때, 한 테이블의 각 해에 대해 다른 테이블의 모든 행을 검색하는 방식) 에 사용하는 인덱스.=> 한 테이블의 행을 순회하면서 다른 테이블 인덱스 사용
    - 조인 컬럼에 인덱스가 걸려 있어야 한다. 
- `Sort Merge Join`: 두개의 대상 테이블을 조인하는 방법 중 하나 
=> 두 테이블의 조인 열을 정렬 후, 정렬된 결과를 스캔하면서 조인 수행
    - 1. 먼저 두 테이블의 조인 열을 각각 정렬
    - 2. 정렬된 두 테이블을 동시에 스캔하면서, 조인 열 값 일치하는지 확인
    - 3. 일치하는 행 찾으면 결과 집합 추가
=> 두 테이블의 크긱 비슷하고, 조인 열의 값이 균등하게 분포되었을 때 효율적
- Hash Join : 두 개의 테이블을 조인하는 방법 중 하나로, 해시테이블이라는 자료구조를 사용하여 조인을 수행함

    - 1. 두 테이블 중 하나를 선택하여 빌드 테이블을 만듬. ( 빌드 테이블은 더 작은 테이블)
    - 2. 조인 열의 값으로 해시함수 만들어서 해시 테이블 생성함
    - 3. other 테이블 스캔 후 조인열에 해시함수 적용
    - 4. 해시 함수의 결과 사용하여 테이블에서 일치하는 행 찾기
    - 5. 결과 집합 추가 

### 테이블 조인시 고려할 요소

- 테이블의 크기: 테이블의 크기가 작다면 `Nested Loop Join`이 효율적일 수 있습니다. 반면에, 두 테이블 모두 크다면 `Hash Join`이나 `Sort Merge Join`이 더 효율적일 수 있습니다.

- 인덱스의 유무와 종류: 조인할 열에 인덱스가 있다면 `Nested Loop Join`이 효율적일 수 있습니다. 반면에 인덱스가 없다면 `Hash Join`이나 `Sort Merge Join`이 더 효율적일 수 있습니다.

- 데이터의 분포: 조인할 열의 데이터가 균등하게 분포되어 있다면 `Sort Merge Join`이 효율적일 수 있습니다.

- 메모리 용량: `Hash Join`은 빌드 테이블이 메모리에 적합할 만큼 충분히 작다면 매우 빠른 성능을 보입니다. 그러나, 빌드 테이블이 메모리에 맞지 않는 경우에는 성능이 저하될 수 있습니다.

### 쿼리 파싱

- Parsing : CPU 소모 심함 
    - 문법 체크 역할 
    - 바인딩(쿼리에 사용되는 변수의 값을 결정하는 과정) 을 하면, 위의 역할들을 이미 있는 걸 캐싱해 옴
- 바인딩 처리 순서 
    - 1. Parse phase: 쿼리가 분석되고, 쿼리의 구조와 문법이 검증됩니다. 이 단계에서는 바인딩 변수가 존재하는지 확인하고, 이 변수들이 적절한 위치에 있는지 검사합니다.

    - 2. Bind phase: 이 단계에서는 바인딩 변수에 실제 값을 할당합니다. 이 값은 쿼리 실행 시 사용됩니다.

### 인덱스

- 커버링 인덱스 : 테이블의 모든 컬럼에 대해 인덱스를 적용하는 것
=> 실제 테이블 데이터를 조회하지 않으므로 I / O 절약 
=> 디스크가 아니라 메모리에서 읽으므로 
