# 1. 랜덤 I/O와 순차 I/O
    a. 풀테이블스캔과 인덱스스캔 중 풀테이블스캔이 더 좋은 경우는?

    인덱스를 통한 검색이 전체 테이블 스캔보다 느릴 수 있기 때문.
   반면, 검색해야 하는 데이터 양이 많으면, 인덱스를 통한 탐색과 정렬에 드는 오버헤드가 전체 테이블 스캔보다 더 크게 작용할 수 있음. => 인덱스를 통해 각각의 매칭되는 행을 찾는 과정이 전체테이블을 순차적으로 읽는 것만큼이나 비효율적일 수 있음. 인덱스를 사용해도 많은 수의 데이터를 검색해야하기 때문에, 이 경우 전체 테이블 스캔이 더 나을 수 있음.
     
# 2. 클러스터링 인덱스란?
- InnoDB 스토리지 엔진에서만 지원하며, PK값이 비슷한 레코드끼리 묶어서 저장하는 것.
- PK에 의해 레코드의 저장위치가 결정됨
- PK 기반의 검색이 매우 빠름
- 클러스터링 인덱스의 리프노드에는 레코드의 모든 컬럼이 저장되어 있음
# 3. 갭락이란?
- 스토리지 엔진 레벨의 잠금 ( 테이블의 데이터를 다루기 위한 락) 
- 레코드가 아닌 레코드와 레코드 사이의 간격을 잠금으로써 레코드의 생성, 수정 및 삭제를 제어한다.
- 실제 레코드를 제외하고, 데이터가 추가될 수 있는 범위에 잠금. 
- 레코드의 앞 뒤에 갭락이 걸림. (레코드와 레코드 사이에 대한 락)
- 즉, 갭락은 아직 존재하지 않지만 지정된 범위에 해당하는 인덱스 테이블 공간을 대상으로 거는 잠금..! 
=> 데이터의 유일성이 보장되는 PK또는 유니크 인덱스에 의한 작업에서는 갭락이 허용되지 않는다. 
=> Phantom Read 방지에 도움이 된다. 
관련 글 : 

https://medium.com/daangn/mysql-gap-lock-%EB%8B%A4%EC%8B%9C%EB%B3%B4%EA%B8%B0-7f47ea3f68bc

# 4. 카디널리티에 대해서 설명해주세요.
- 카디널리티는 데이터베이스 테이블의 열에 있는 다른 값들의 수를 의미
- 높은 카디널리티는 많은 유니크한 값들을 가진다는 것을 의미 => 인덱스 성능에 긍정적임
- 낮은 카디널리티는 중복된 값이 많은 것을 의미하고 이는 인덱스 효율을 떨어뜨림. 
# 5. SQL문에서 Query의 작동 순서?
from : 각 테이블 확인
on : 조인 조건 확인
join : 테이블 조인(병합)
where : 데이터 추출 조건 확인
group by : 특정 컬럼으로 데이터 그룹화
having : 그룹화 이후 데이터 추출 조건 확인
select : 데이터 추출
distinct : 중복 제거
order by : 데이터 정렬
# 6. RDB와 MongoDB의 차이?
    a. join
    => RDB : 테이블간의 관계를 기반으로 하여, 결합하는데 사용. 다양한 유형 조인 수행가능
    Mongodob : 일반적으로 조인 지원하지 않음. 문서기반이라 데이터를 중첩하여 저장.
    b. 샤딩
    => 
    RDB : 샤딩을 수동으로 추가해야함. 
    mongodb : 
    1. 샤딩을 네이티브로 지원함
    2. 데이터는 자동으로 여러 서버에 분산되어 자장되며, 이를 통해 수평적 확장성을 쉽게 달성할 수 있음
    3. 고가용성과 분산처리에 특화. 
    c. 트랜잭션
    RDB : ACID 속성 / 트랜잭션 기능과 롤백기능 제공
    mongodb : 광범위한 트랜잭션을 지원하지는 않음.
