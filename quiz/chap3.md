
# 1. String에 + 연산을 하면 성능이 안 좋다던데 왜 그럴까요
- String 객체는 immutable하고, 문자열의 내용을 변경할 수 없음. 문자열을 연결할 때마다 새로운 String 객체를 생성함. 이렇게 되면 기존 객체 문자열에서 값을 이어붙이는게 아니라 새로운 문자열을 생성하기 때문에 오버헤드가 발생함.
=> 새 문자열을 제외한, 기존의 사용되지 않는 문자열을 GC하는 작업이 추가적으로 발생함. 

이를 해결하기 위해 StringBuilder와 StringBuffer사용이 권장됨. 
두 클래스의 차이점은 다음과 같다. 

=> StringBuffer : thread-safe =>  내부적으로 sychronized키워드로 구현되어있기 때문 

=> StringBuilder : 스레드 안전하지 않음 / 대신 StringBuffer대비 병렬적으로 빠르게 처리 가능.

# 2. 자바8 스트림에 대해서 설명해주세요.
- 스트림 사용하면서 장점이라고 생각했던 부분은?
1. 코드의 양을 줄이고 가독성있게 간결하게 표현 가능
2. 배열과 컬렉션을 함수형으로 처리 가능

- 병렬스트림 사용해본적 있나? 어떤 경우에 사용하면 좋을까요?
하나의 작업을 둘 이상의 작업으로 잘게 나눠서 동시에 처리하는 것. 
쓰레드를 이용해 많은 요소들을 빠르게 처리할 수 있음 
parrallelStream메서드를 사용하여 병렬 스트림을 쉽게 생성할 수 있음.

======

스트림 생성 3가지 과정

1. 생성하기 : 스트림 인스턴스 생성
2. 가공하기 : 필터링 or mapping등 원하는 결과를 만들어가는 중간 작업
3. 결과 : 최종 결과를 만들기

# 3. Http Keep Alive에 대해서 설명해주세요.
HTTP는 Connectionless방식으로 연결을 끊고, 새로 생성하는 방식이어서, 최초 연결을 하기 위해 많은 비용을 소비한다.

HTTP 프로토콜을 사용하는 웹 서버와 클라이언트 간의 연결을 유지하고, 이미 연결되어있는 TCP연결을 재사용하는 기능이다. 
즉 3-way handshake를 통해 연결된 세션을 없애지 않고 계속 사용하는 방식이다.

옵션으로 timeout과 max가 있다

timeout : keep alive를 유지하는 시간
max : keep alive의 횟수 제한

최소 요청시간 / 최대 요청 수를 알려주는 값임.

 
- 장점 : HandShaking과정이 생력되므로 성능 향상을 기대할 수 있다. 

- 단점 : 사용자가 많고 유동이 많은 서비스에서 사용이 권장되지 않음. => why ? 연결이 계속 유지되므로, 서버 부하 증가 가능. 각 연결은 서버의 메모리를 점유하므로! 
 
# 4. DB인덱스의 자료구조에 대해서
- b+tree의 장점? 단점에 대해서

## 장점 
1. 균형트리구조 : B+Tree는 균형 트리 구조를 갖고 있어서, 모든 리프노드가 동일한 레벨에 있음. 이로 인해 검색 연산에 필요한 시간이 효율적으로 관리됨.

2. 리프노드가 연결리스트로 구성되어 있어서, 순차 검색 및 범위 검색에 효율적임.

## 단점

1. 삽입 및 삭제 작업에서 오버헤드가 발생함. (노드의 분할 및 병합 연산으로 균형 트리구조로 유지시켜주어야하기 때문)

# 5. 커버링 인덱스이 무엇인지 설명해주세요.

- 쿼리를 충족시키는데 필요한 모든 데이터를 가지고 있는 인덱스.
=> 커버링 인덱스를 잘 사용하면, 조회 성능을 상당히 높일 수 있다.
=> 왜냐하면, 데이터 열을 인덱스 자체에 포함하기 때문에 원본 테이블을 액세스할 필요 없기 때문.
- DBMS에서 사용하는 개념으로, 쿼리의 성능을 최적화하기 위해 인덱스를 활용하는 방법 중 하나
- 쿼리의 필요한 모든 데이터를 인덱스 자체에서 가져올 수 있는 인덱스
- 대용량 테이블에서 효과적임
- 커버링 인덱스를 사용하면, 쿼리 옵티마이저가 더 효율적인 실행계획을 수립할 수 있어 쿼리의 실행시간 단축 가능
- SELECT, WHERE, ORDER BY, GROUP BY 등에 사용되는 모든 컬럼이 인덱스의 구성요소인 경우
- 즉 쉽게 말하자면, 쿼리에 필요한 열만을 인덱스에 포함하는 것.


# 6. 스프링에서 정의한 클래스 빈(예. service, component 등등)이 있습니다. 이 클래스 A에 a()라는 메서드가 있고, b()라는 메서드가 있습니다. b()라는 메서드에는 @Transactional 이 선언되어 있습니다. a()메서드에서 b()라는 메서드를 호출하는 구조일 때 트랜잭션이 동작할까요?

- 서로 다른 빈이면, 동작하지 않음. 왜냐하면 스프링의 프록시 기반 AOP가 관련된 메서드 호출에만 적용되기 때문.
- Spring AOP를 이용해 @Transactional 어노테이션을 선언한 메서드가 실행되 전, transaction begin을 실행하고, 메서드 실행 후에 Transaction commi코드를 삽입하여, 객체 변경 감지를 수행하도록 유도함

- Spring의 코드 삽입방식 2가지
1. 바이트 코드 생성 => Spring Boot 
2. 프록시 객체 사용 => Spring

- 프록시의 동작 원리에 따라, 외부 메서드 - 내부 메서드 관계에서 @Transactional을 외부 메서드에 붙여야, 트랜잭션 적용이 올바르게 수행됨.
- 대상 객체 대신에 프록시를 스프링 빈으로 등록하기 때문 / 때문에, 스프링은 의존관계 주입시에 항상 실제 객체 대신에 프록시 객체를 주입함. 
- 대상 객체 내부에서 자신의 다른 메서드 호출이 발생하면, 프록시를 거치지 않고 대상 객체를 직접 호출
- 스프링은 aop안에서 자기 자신의 메서드를 호출하면 aop가 적용되지 않음.

https://hungseong.tistory.com/81

# 7. @Transactional어떻게 동작 하길래 메서드 위에 선언만 해도 트랜잭션이 동작할까요?

@Transactional 어노테이션을 메서드 위에 선언하면 해당 메서드가 트랜잭션 안에서 실행되도록 스프링에 알림. 이 메서드의 실행을 트랜잭션으로 감싸서, 해당 메서드에서 예외가 발생하지 않는 한 메서드의 작업을 롤백하거나 커밋할 수 있음.

1. 메서드가 호출되면 새로운 트랜잭션 시작
2. 메서드가 예외를 던지지 않는 한, 메서드 내 모든 작업 해당 트랜잭션 내에서 실행됨
3. 메서드가 완료되면 트랜잭션 자동 커밋됨

# 8. 응집도와 결합도는 무엇일까?
- 응집도가 높은 코드? 낮은 코드? 예를 들면 어떤 코드가 있을까?

하나의 모듈이 하나의 기능을 수행하는 요소들간의 연관성 척도
독립적인 모듈이 되기 위해서는 응집도가 강해야 한다.
단일책임을 가진 클래스

=> ex) Controller / Service / Repository 패턴 => 
컨트롤러는 restful엔드포인트 정의하는데에 집중하고
서비스는 비즈니스 로직을 처리하는데 집중
레포지토리 => 디비 연동에 집중하여 지원 

- 결합도가 높은 코드? 낮은 코드? 예를 들면 어떤 코드가 있을까?
어떤 모듈이 다른 모듈에 의존하는 코드로
모듈 내부의 각 구성요소들이 연관이 없을 경우 가장 좋지 않은 응집도임.
=> 결합도가 낮은 코드는 OCP원칙을 잘 지킨 코드로, JDBC API를 들 수 있다.

=> 관련해서 https://mslilsunshine.tistory.com/116 요런것도 계속 보면서...감 잃지말기
# 9. 스프링을 공부하면 등장하는 단어 IoC란 무엇일까요?

제어의 역전 / 개발자가 직접 객체를 관리하지 않고 스프링 컨테이너에서 직접 객체를 생성하여 해당 객체에 주입시켜준 것.


# 10. IoC와 DI는 어떤 차이가 있는 걸까요?

IOC는 프로그램 제어권을 역전시키는 것.
DI는 해당 개념을 구현하기 위해 사용하는 디자인 패턴 중 하나.
객체의 의존 관계를 외부에서 주입시키는 패턴

# 11. 라이브러리와 프레임워크의 차이는 무엇일까?

가장 큰 차이는 제어흐름이 어디에 있는가인것.

프레임워크는 제어의 역전 개념이 적용되어 있어, 프레임워크에게 제어의 흐름을 넘겨 개발자가 작성하는 코드에서 신경써야 할 부분을 줄인다는 것.

라이브러리는 개발자가 전체적인 흐름을 만들며 라이브러리를 가져다 쓰게 되는 것.

======

1. 
** parallelStream : 병렬적으로 스트림 연산 수행 

=> 장점 : 시작시간 끝 시간 (똑같은 로직 수행) / 병렬
=> 어떨 때 쓰면 좋지 ?
=> 일반적으로 단순히 일반적인 로직을 수행할 때?? 
=> 목록형 api 각 element api마다 가져와야함 
=> 병렬 api호출 할 때

2. Keep - alive 조사 

3. B+Tree : 기울어진 트리 (불균형 트리 => 일정 성능 보장 : 방점에)

 삽입 / 삭제 속도가 느리다 / 조회 성능은 빠르다

4. 커버링 인덱스 (covering index)