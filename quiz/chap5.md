# 1. 동기 vs 비동기, 블록킹 vs 논블록킹

- a. Spring Webflux와 JDBC와의 조합이 문제가 있는 이유에 대해

  Spring Webflux와 JDBC:

  Spring Webflux: 비동기 및 논블록킹 웹 프레임워크로, Reactive Programming을 기반으로 함.
  JDBC: Java Database Connectivity, 데이터베이스와의 연동을 담당하는데, 기본적으로 동기적이고 블록킹.
  문제점:

  Spring Webflux와 JDBC를 함께 사용하면, Webflux가 비동기이고 논블록킹이지만, JDBC는 동기적이고 블록킹이라는 불일치가 발생할 수 있음.
  이로 인해 블록킹 작업이 발생하면 전체 시스템이 논블록킹의 이점을 잃을 수 있음.

  b. 어떻게 하면 되나?
  해결방법:

  비동기적인 데이터베이스 액세스: Spring Data R2DBC 등을 사용하여 비동기적으로 데이터베이스와 상호 작용할 수 있음.
  Reactive 데이터베이스 드라이버 사용: Reactive한 방식으로 동작하는 데이터베이스 드라이버를 사용하여 블록킹을 피할 수 있음.
  비동기적인 JDBC 드라이버: 몇몇 JDBC 드라이버는 비동기적으로 동작할 수 있으므로, 해당 드라이버를 사용하는 것도 고려할 수 있음.
  참고:

  Spring Webflux에서는 Reactive 스타일의 데이터베이스 액세스를 권장하며, 블록킹 호출은 최소화해야 합니다.
  어떻게 하면 되나:

  Spring Data R2DBC 사용: R2DBC를 사용하여 비동기적으로 데이터베이스에 액세스할 수 있습니다.
  Reactive 데이터베이스 드라이버 선택: 데이터베이스에 따라 Reactive한 드라이버를 선택하여 사용합니다.
  논블록킹 API 사용: Spring Webflux가 제공하는 논블록킹 API를 활용하여 개발합니다.

# 2. 컴파일 언어 vs 인터프리터 언어?

- 컴파일 언어 : 소스코드를 기계어로 컴파일해서 실행파일을 만들어 실행하는 방식. 컴파일 언어는 원시코드(프로그래머가 작성한 소스코드)를 한 번에 기계어로 변환하여 실행파일을 만든다. 컴파일 단계와 실행 단계가 분리 되어 있다.
  한번에 모든 코드를 컴파일 하여 실행전에 오류 파악 가능. 코드를 수정하면 다시 컴파일 과정을 겪어야 함.
  종류로 C, C++이 있다.

- 인터프리터 언어 : 코드를 한 줄 씩 내려가며 실행하는 방식. 인터프리터 언어는 소스코드를 기계어로 번역하는 과정 없이 한 줄 씩 해석하여 바로 명령어를 실행한다. 컴파일링 과정이 없고 실행시마다 한 줄씩 인터프리트 해야하기 때문에 비교적 실행 속도가 느리다.

R, Pyhton, Ruby 가 대표적인 인터프리터 언어이다.

여기서 자바는 컴파일러와 인터프리터 언어의 특징을 함께 지님.
JVM(자바 프로그램을 실행하기 위한 가상머신)은 자바소스코드를 컴파일 하여 바이트 코드를 생성하고, 이 바이트 코드를 런타임시에 한 줄씩 인터프리트 함.

# 3. Http Stateless, Connectionless한 속성에 대해

- Stateless (무상태성):

HTTP 프로토콜은 상태를 유지하지 않는 특성을 갖습니다. 각각의 요청은 이전 요청과 독립적으로 처리됩니다. 서버는 클라이언트의 상태를 기억하지 않으며, 각각의 요청은 필요한 모든 정보를 포함해야 합니다. 이 특성은 서버 측에서 사용자 상태를 저장하거나 관리하지 않아도 되기 때문에 확장성이 높아지고, 서버 부하를 줄일 수 있습니다.

- Connectionless (비연결성):

HTTP는 기본적으로 연결을 유지하지 않는 특성을 가지고 있습니다. 각각의 요청은 서버와의 임시적인 연결을 맺고, 응답 후에는 연결이 끊어집니다. 이는 리소스를 효율적으로 사용할 수 있게 하며, 많은 수의 클라이언트와 통신할 때 성능을 향상시킵니다. 그러나 연결이 없기 때문에 클라이언트와 서버 간의 상태를 유지하기 어렵습니다.

a. connectionless한 속성을 보완하는 방법으로 나온 것은?

쿠키 (Cookies): 클라이언트와 서버 간의 상태를 유지하기 위해 쿠키를 사용할 수 있습니다. 쿠키는 클라이언트 측에 저장되며, 클라이언트가 서버에 다시 요청을 보낼 때 함께 전송됩니다. 이를 통해 클라이언트의 이전 상태를 서버가 인식할 수 있습니다.

세션 (Session): 서버 측에서 상태를 유지하기 위해 세션을 사용할 수 있습니다. 세션은 서버에 저장되며, 클라이언트는 세션 식별자를 받아 사용합니다. 서버는 클라이언트의 세션 정보를 유지하면서 상태를 보존합니다.

토큰 기반 인증 (Token-based Authentication): 비연결성으로 인해 사용자의 인증 상태를 유지하기 위해 토큰을 사용할 수 있습니다. 클라이언트가 한 번 인증되면, 서버는 토큰을 발급하고 이를 이용하여 클라이언트의 상태를 인식합니다.

# 4. Content Negotiation에 대해서

클라이언트 및 서버간에 사용가능한 표현 형식을 협상하는 방식.
특정 헤더를 주로 사용함.

a. 어떤 헤더가 사용되는지?

- Accept 헤더 : 클라이언트가 지원하는 미디어 타입 목록을 서버에 전달함.
  ex) "Accept: application/json"은 클라이언트가 JSON형식의 응답을 선호함을 나타냄
  =>
  -> Accept : 클라이언트가 처리하고자하는 미디어 리소스타입
  -> Accept-charset: 클라이언트가 이해할 수 있는 캐릭터 인코딩
  -> Accept-encoding : 수용 가능한 콘텐츠 인코딩
  -> Accept-language : 클라이언트가 사용하는 언어

- Cotent-type 헤더 : 클라이언트가 보내는 요청의 본문에 포함된 데이터 형식 나타냄. 주로 POST / PUT요청에서 활용함

b. Spring Mvc에 있는 WebMvcConfigurer 클래스에 인터페이스 명시되어있음.

```java

@Configuration
@EnableWebMvc
public class WebConfig implements WebMvcConfigurer {

    @Override
    public void configureContentNegotiation(ContentNegotiationConfigurer configurer) {
        configurer
            .ignoreAcceptHeader(false) // Accept 헤더 무시 여부
            .defaultContentType(MediaType.APPLICATION_JSON)
            .mediaType("xml", MediaType.APPLICATION_XML)
            .mediaType("json", MediaType.APPLICATION_JSON);
    }
}

```

# 5. RDB와 몽고DB의 차이 및 어느 특성을 가진 서비스에 적절하게 사용될지에 대해

a. JOIN이 필요한 경우를 자세히 설명해주신다면?

- 두 개 이상의 테이블이나 디비를 연결하여 데이터를 검색하는 방법
- 데이터가 하나의 Relation으로 전부 저장되는 것이 아닌, Relation의 지켜야할 속성들을 만족하는 여러 개의 Relation으로 저장된다.
- 여러 Relation 사이의 데이터를 조합하여 하나의 총체적인 데이터를 구성할 필요가 생김.

b. 트랜잭션의 관점에서는? =>

- RDB는 ACID 특성을 준수하여 데이터 일관성과 안정성 보장함.

acid란 ?  
ACID
-Atomicity(원자성) : 트렌젝션이 중간에 중단되지 않고 처음부터 끝까지 수행하는 것

-Consistency(일관성) : 트랜잭션이 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 유지하는 것

-Isolation(격리성) : 트렌젝션 처리 중에 간섭하지 못하도록 하는 것

-Durability(지속성) : 하나의 트렉젝션이 발동하면 하드디스크에 영구히 저장되는 것

- MongodB는 모든 상황에서 ACID 를 보장하지 않음.

c. 읽기 성능과 관련해서는?

RDB(Relational Database)에서의 읽기 성능:

- 쿼리 최적화 및 인덱싱을 통해 데이터베이스 시스템은 빠른 읽기 성능을 제공
- 특히 정규화된 데이터 구조를 갖추어 데이터 중복이 최소화되면서 응용 프로그램의 일관성을 유지

NoSQL 데이터베이스에서의 읽기 성능:

- 데이터 중복이 허용되어 복잡한 JOIN 연산이 필요 없음.
- 수평적 확장이 쉽게 이루어지므로 대량의 데이터를 처리하는 데 효과적일 수 있음.

d. 쓰기가 더 빠른다고 하신 이유는?

- rdb : ACID특성을 보장하기 위해 쓰기가 상대적으로 복잡함
- mongodb : 데이터가 중복 저장되거나, 문서단위로 저장되어 복잡한 join연산 필요하지 않음. 쓰기 작업의 복잡성을 줄이고, 빠른 쓰기 성능을 보장하는 데 도움을 줌 => 스키마가 없기 때문에, 언제든 필드 추가할 수 있지만 중복된 데이터가 들어갈 수 있으며, 이에 따라 정합성이 떨어짐.

+) RDB: 트랜잭션의 일관성과 안정성이 중요한 비즈니스 프로세스에 적합합니다. 예를 들어 금융 서비스, 주문 처리 등.
NoSQL: 높은 읽기/쓰기 처리량과 유연성이 필요한 경우에 적합합니다. 예를 들어 대용량의 로그 데이터, 소셜 미디어 애플리케이션 등.

# 6. Restful API에 대해

REST :

1. HTTP URI를 통해 자원을 명시하고
2. HTTP Method를 통해
3. 해당 자원(URI)에 대한 CRUD Operation을 적용하는 것을 의미

RESTful API :
Rest 의 원리를 따르는 API

1. URI는 동사보다 명사를, 대문자보다 소문자 사용
2. 마지막에 슬래시 포함 x
3. 언더바 대신 하이픈
4. 파일 확장자는 uri에 포함시키지 않음
5. 행위를 포함하지 않음

GET : 리소스 조회
POST : 요청 데이터 처리
PUT : 리소스 대체, 해당 리소스가 없음 생성
PATCH : 리소스 부분 변경
DELETE : 삭제

HEAD : uri와 동일한 get 요청 보냄 => 본문 빼고 헤더만 보냄.
=> Get요청 body랑 같이 보내기 전 사전 정보 확인하는 것
OPTIONS:
서버나 특정 uri에 해당하는 리소스가 제공하는 기능을 확인할 때 사용
서버가 살아있는지, 해당 리소스를 처리할 수 있는지 확인
혹은 어떤 메서드를 지원하는지?
