# 1. 응집도와 결합도는 무엇을 말하는 것일까요?

- 응집도 : 모듈 혹은 클래스 내부에서 서로 얼마나 관련있는지 나타냄.
- 결합도 : 모듈 또는 클래스 간의 상호 의존성을 나타냄. 낮은 결합도 -> 모듈 간 의존성이 낮아, 변경이 쉽고 유지보수가 용이함. 
# 2. IOC란 무엇일까요?
- 제어의 역전, 객체의 생성 및 관리를 개발자가 아닌 프레임워크에 넘기는 것. 이를 통해 느슨한 결합을 유지하고, 테스트 용이성을 높임. 
# 3. DI란 무엇인가요?
- 의존성 주입을 나타내는 개념으로, 객체간의 의존성을 코드 외부에서 주입하는 방법을 의미. 코드의 재사용성과 테스트 용이성을 증가시킴

# 4. 스프링에서 의존성을 외부에서 주입해주면 장점이 무엇인가요?
- 스프링은 DI를 지원하는 프레임워크로, 의존성 주입을 통해 여러 이점 얻을 수 있음

1. 느슨한 결합도 : 객체간의 결합도 낮아짐.

2. 테스트 용이성 : 의존성을 모의객체로 대신하여 단위 테스트 수행 가능

3. 코드의 재사용성 : 의존성을 주입받는 객체는 재사용이 용이 

4. 제어 역전 : 스프링 컨테이너가 객체의 생명주기를 관리하므로, 개발자가 객체 생성 및 관리에 신경 쓸 필요 없음.

# 5. 라이브러리와 프레임워크의 차이는?
- 라이브러리 : 개발자가 필요한 기능을 수행하기 위해 호출할 수 있는 함수나 클래스 집합
- 프레임워크 : 애플리케이션 구조와 흐름을 정의한 뒤, 개발자는 프레임워크의 규칙에 따라 코드를 작성해야 함.
# 6. AOP란 무엇인가?
- 관심사를 모듈화하고 코드 중복을 최소화하기 위한 프로그래밍 패러다임
- 주요 관심사 외 부가적인 관심사를 모듈화하여 코드의 응집도를 높이고 중복을 줄인다. 
- 애플리케이션의 여러 모듈에서 공통으로 사용되는 관심사를 분리하고 재사용 가능한 방법으로 제공함. 
# 7. AOP는 내부적으로 어떻게 구현되어 있나요?
- 주로 프록시 패턴을 사용하여 구현됨. . 프록시는 원본 객체(타겟)에 접근할 때 중간에서 요청을 가로채고 부가적인 동작을 수행한 뒤 원본 객체에 대한 요청을 처리. 스프링 AOP에서는 JDK Dynamic Proxy와 CGLib을 사용하여 프록시를 생성하며, 어떤 방식을 선택할지는 타겟 객체의 유형과 인터페이스의 존재 여부에 따라 달라짐.
# 8. JDK Dynamic Proxy, CGLib는 무엇인지? 어떤 차이가 있는지?

JDK Dynamic Proxy: Java에서 제공하는 동적 프록시 생성 기능. 인터페이스를 구현한 클래스에 대한 프록시를 생성할 수 있으며, 인터페이스의 메서드 호출을 가로채서 부가 동작을 수행. 인터페이스를 구현한 클래스에만 사용 가능. 

CGLib: CGLib은 클래스의 상속을 이용하여 프록시 객체를 생성하는 라이브러리임. 인터페이스를 구현하지 않은 클래스에도 프록시를 생성할 수 있으며, 클래스 내부의 메서드 호출을 가로채서 부가 동작을 수행. 단, 상속을 사용하기 때문에 final 클래스나 메서드에는 적용할 수 없음. 
# 9. 인덱스가 제대로 실행되지 않는다면, 어떻게 분석해볼 수 있을까?
인덱스가 제대로 실행되지 않을 때 다음 단계를 따를 수 있음. 
1. 쿼리 실행 계획 분석: 데이터베이스 쿼리 실행 계획을 확인하여 쿼리 옵티마이저가 어떤 인덱스를 선택하는지 확인
2. 인덱스 상태 확인: 인덱스가 손상되지 않았는지 확인하고, 필요한 열에 대한 인덱스가 존재하는지 확인.
3. 테이블 통계 갱신: 데이터베이스 통계 정보가 최신인지 확인하고, 필요한 경우 통계 정보를 갱신.
4. 인덱스 힌트 사용: 필요하다면 데이터베이스에서 인덱스 사용을 강제하는 힌트를 제공할 수 있음.
5. 인덱스 재생성: 인덱스가 손상되었거나 비효율적인 경우, 인덱스를 다시 생성할 수 있음. 

# 10. “이름“, “나이“, “성별“컬럼으로 복합키 인덱스를 구성할 때 주의해야 할점은?
- 카디널리티 : 인덱스된 컬럼의 고유 값 수를 고려해야함.
카디널리티가 높을 수록 인덱스의 효율성이 증가함.
성별 -> 카디널리티가 낮은 편으로, 이 컬럼이 맨 앞에 오면 인덱스의 효율이 떨어짐
- 선택도 : 선택도가 높을수록 쿼리의 성능이 좋아짐
- 인덱스 순서도 중요 : 가장 자주 사용되고, 가장 높은 카디널리티를 가진 컬럼을 인덱스 앞 쪽에 배치하는 것이 중요함. 
- 데이터 삽입, 삭제, 업데이트시에 유지되어야함. 복합키 인덱스는 이러한 작업의 비용을 증가시킬 수 있으니, 이러한 비용도 고려 
- 인덱스 크기 : 인덱스 크기가 커지면, 저장 공간 요구사항과 메모리 사용량이 증가함.

    [퀴즈]
# 11. Compile time weaving, Load Time weaving이 무엇인가요?

- Weaving : 모듈화한 부가 기능을 타겟에 적용하여 핵심 기능과 연결하는 과정

- Runtime Weaving : 
* 프록시 패턴을 활용한 위빙 방식.
* Proxy 객체를 생성하여 실제 타깃 오브젝트의 변형 없이 런타임 중 메서드 호출이 일어나는 시점에 위빙을 수행함.
* 메서드 호출에 대해서만 어드바이스 적용 가능.

- Compile Time Weaving : 
* CTW는 소스코드가 컴파일 될 때 어스펙트를 기본 코드에 통합하는 과정. 
컴파일 과정에서 바이트 코드 조작함.
* 특수한 컴파일러를 사용하여, 컴파일 과정에서 바이트 코드 조작을 통해 Advisor 코드 직접 삽입. 
=> 런타임에 별도의 처리가 필요 없어, 성능적으로 이점이 있다. 

- Load Time Weaving : 
* 자바 클래스가 JVM에 로드될 때, 바이트 코드 조작을 통해 위빙되는 방식. 
* 프로그램이 실행될 때, 클래스가 JVM에 로드되는 시점에 어스펙트를 통합하는 방식.

# 12. Spring AOP vs AspectJ는 어떤 차이가 있을까요?
