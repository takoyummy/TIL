# 1. 스프링에서 AOP란 무엇인가요?

- AOP는 소프트웨어 개발에서 관심사의 분리를 통해 모듈화를 개선하는 프로그래밍 패러다임중 하나
- 스프링 AOP (Aspect-Oriented Programming)는 프로그램의 다양한 부분에서 공통된 관심사(코드)를 분리하여 모듈화하고, 이를 필요한 위치에서 적용할 수 있도록 도와주는 기술
- 목적 : "중복을 줄여서, 적은 코드 수정으로 전체 변경을 할 수 있게 하자"
- 관심사의 분리

1. Aspect : Advice + Pointcut (일정한 패턴을 가지는 클래스에 advice를 적용할 수 있도록 지원)
2. Advice : JoinPoint에서 실행되어야 하는 프로그램 코드. 독립된 클래스의 메서드로 작성한다. 실질적으로 어떤 일을 해야할 지에 대한 것, 실질적인 부가기능을 담은 구현체
3. JoinPoint : 메서드를 호출하는 시점, 예외가 발생하는 시점과 같이 애플리케이션을 실행할때 특정 작업이 실행되는 시점을 의미, Advice를 적용할 수 있는 위치. 끼어들 수 있는 지점.
4. PointCut : 여러 JoinPoint의 집합체로 언제 Advice를 실행할지를 정의.
5. Weaving : Aspect를 해당 지점에 주입하는 과정. AOP에서 JoinPoint들을 Advice로 감싸는 과정을 Weaving이라고 함.
   Weaving작업을 도와주는 것이 AOP툴이 하는 역할.

a. 내부적으로 어떻게 구현되어있을까?

- Proxy Pattern을 사용하여 AOP기능을 구현함. 원복 객체의 기능을 확장하거나 변경하지 않고, 프록시 객체를 생성하여 필요한 공통 관심사를 추가함. 클라이언트 코드는 프록시 객체를 통해 타겟 객체에 접근하며, 프록시 객체는 필요한 AOP동작을 수행함.

이때 타겟 객체의 메서드 호출을 가로채어, Aspect에 정의된 Advice를 실행함. 스프링은 JDK 프록시 또는 CGLIB프록시를 사용해서, 프록시를 생성할 수 있음.

b. 내부적으로 구현되어 있는 특징을 고려할때 AOP로 구현코드를 사용할 때 어떤 점을 주의해서 구현해야 할까요?

- 외부에서 내부메서드를 호출할때 의도와 달리,
  실제 객체의 내부 메서드가 호출될 가능성이 있음.

=> 따로 클래스로 만들어 내부 메서드를 빼서 별도의 빈으로 등록해야함.

# 2. Spring AOP와 aspectJ는 어떤 차이가 있을까요?

a. 위빙 방식, 성능

- aop : 런타임 시점에 프록시를 생성해서, aop를 적용함 => 런타임 위빙방식 / 프록시 기반 AOP => JDK 동적 프록시 or CGLIB를 사용해서 프록시 객체를 생성하므로, 프록시를 통한 호출에 약간의 오버헤드가 있을 수 있음. Spring과의 통합 및 사용 편의성이 뛰어남.

- aspectJ : 컴파일시점에 AOP코드를 원본 코드에 위빙하는 방식. 런타임시점에 프록시를 생성하는게 아니라 Spring AOP보다 성능면에서 우수함.
  설정 및 사용이 조금 더 복잡함.

b. 구조

- Spring AOP : 스프링 프레임워크 내에서 제공되며, 스프링 컨테이너와 통합되어있음. 프록시를 생성하고, 관리하는 기능을 스프링 프레임워크가 제공하므로 스프링 애플리케이션과의 연동이 쉬움

- AspectJ: 독립적인 AOP프레임워크로서 별도의 컴파일러와 설정 파일이 필요함.

c. 적용 범위

- Spring AOP : 메서드 호출 및 실행 시점에서의 어드바이스 적용을 주로 지원함. 메서드 레벨에서의 AOP적용이 주로 이루어짐. 클래스 레벨에서의 적용은 제한적임

- AspectJ : 더 넓은 범위의 적용을 지원함. ex) 클래스, 필드 액세스, 객체생성...
  다양한 지점 (PointCut)애에서 AOP 적용 가능.

# 3. RDB 등에서 가장 많이 사용하는 인덱스는 어떤 자료구조를 가지고 있을까?

B+Tree

a. 장점, 단점

## 장점 :

1. 균형트리 구조를 가지고 있어, 디비에서 빠른 검색을 제공함.
   검색 연산의 시간 복잡도는 O(log n) 으로 디비 크기에 관계 없이 일정함.
2. 말단의 리프 노드에 데이터가 있고 링크드 리스트로 연결되어 있어서 범위 검색에 유리함.

## 단점 :

1. 삽입 및 삭제 비용 : 트리의 재조정을 동반하므로 비용이 상대적으로 높을 수 있음. 대량의 삽입 및 삭제가 필요한 작업에서 오버헤드가 발생함

# 4. DB의 Isolation Level에 대해서 설명해주세요.

- Read Uncommited (level 0) : 가장 낮은 격리 수준으로, 이 수준에서 하나의 트랜잭션이 수행하는 동안, 다른 트랜잭션에서 변경중인 데이터를 읽을 수 있음. 이를 dirty read라고 함.
  (dirty read : 하나의 트랜잭션이 아직 커밋되지 않은 다른 트랜잭션에서 변경한 데이터를 읽는 현상)

- Read Committed (level 1) : 트랜잭션이 완료될 때까지 변경 중인 데이터를 다른 트랜잭션에서 읽을 수 없음. 팬텀리드 발생 가능.
  (phantom read : 하나의 트랜잭션이 동일한 쿼리를 두 번 실행할 때 다른 결과를 얻는 현상)

- Repeatable Read (level 2) : 트랜잭션동안 조회한 데이터를 다른 트랜잭션에서 변경할 수 없음.

- Serializable (level 3) : 가장 높은 격리 수준. 트랜잭션 간에 완전한 격리가 유지됨. 더티 리드, 팬텀 리드등의 문제가 발생하지 않지만, 동시성이 낮아지고 성능이 저하될 수 있음.

# 5. 랜덤 I/O와 순차 I/O에 대해서 설명해주세요.

- 랜덤 I / O : 데이터를 임의의 위치에서 읽거나 쓰는 작업. 무작위로 흩어진 위치에 있는 데이터를 액세스.

* 디스크의 특정 섹터나 스토리지 장치의 임의 위치에 저장된 데이터를 읽거나 쓸 때 발생함
* 디스크 헤드가 움직이는 시간과, 회전 대기시간이 필요하여 순차 I/O보다 느릴 수 있음
  ex) 디비의 레코드 검색, 파일 시스템의 임의 파일 액세스

- 순차 I / O : 데이터를 연속된 순서로 읽거나 쓰는 작업. 데이터를 순서대로 연속된 위치에 읽거나 쓰는 것.
  순차 I / O는 주로 대용량 데이터 블록을 읽거나 쓸 때 발생함. 파일의 처음부터 끝까지 읽거나 쓰는 것이 순차 I / O

ex) 대용량 로그파일 분석, 디비 파일 백업

# 6. 객체지향에서 다형성이란 무엇인가요?

다형성은 같은 인터페이스 또는 기본 클래스로 사용하여, 서로 다른 하위 클래스의 객체를 다룰 수 있는 기능을 제공함
ex) 오버로딩 / 오버라이딩 / 업캐스팅 / 동적 바인딩 / 추상 클래스 & 인터페이스 활용

# 7. RDB와 MongoDB를 비교한다면?

- RDB

* 데이터는 테이블에 레코드로 저장되고, 각 테이블에는 명확하게 정의된 구조가 있음
* 엄격한 스키마. 스키마를 준수하지 않는 레코드는 추가할 수 없다.
* 데이터들을 여러개의 테이블에 나누어서, 데이터들의 중복을 피할 수 있다.
* 데이터 무결성 보장

단점

- 수평적 확장이 어렵고, 대체적으로 수직적 확장만 가능함.
- 관계를 맺고 있어서, JOIN문이 매우 많은 복잡한 쿼리 만들어 질 수 있음

용도

- 변경될 여지거 없고ㅡ 명확한 스키마가 필요할 경우
- 관계를 맺고 있는 데이터가 자주 변경되는 애플리케이션일 경우

* MongoDB

- 스키마 없음, 관계 없음
  => 다른 구조의 데이터를 같은 컬렉션에 추가할 수 있음.
  => 조인이라는 개념이 존재하지 않고- 조인을 사용할 필요가 없어서, 복잡하고 느린 조인 절차를 겪을 상황이 없음.
- 애플리케이션이 필요로 하는 형식으로 저장되어, 데이터를 읽어오는 속도가 빠름

단점

- 데이터 구조 결정을 하지 못하고, 미루게 될 수 있음
- 여러 컬렉션과 문서가 여러개의 레코드가 변경된 경우 업데이트를 해야함
- 수정을 해야하는 경우 모든 컬렉션에서 수행되어야함

용도

- 정확한 데이터 구조를 알 수 없거나, 변경, 확장될 수 있는 경우
- 읽기 처리를 하지만, 데이터를 자주 변경하지 않는 경우
- 디비를 수평으로 확장해야하는 경우

# 8. 리플리케이션과 샤딩이 각각 무엇인지

- 리플리케이션 : 디비에서 데이터의 복제본을 여러개 만들어, 여러 서버 또는 노드에 분사 저장하는 기술. 복제된 데이터는 동일한 데이터를 여러 장소에서 읽을 수 있게 하거나 장애 대비 및 부하 분산을 위해 사용됨. 읽기 작업이 많은 시나리오에서 성능을 향상시키는데 사용됨.
  여러개의 디비를 master-slave형태로 구축함.
  master에 dml을하고 ,slave에서 복제하는 방식
  비 동기 방식으로 노드들간의 데이터를 동기화함.

- 샤딩 : 대용량 디비를 더 작은 조각으로 분할하여 여러 서버 또는 노드에 분산 저장하는 기술. 각 조각은 독립적으로 작동하여 디비에 대한 부하를 분산시킴.

# 9. 샤딩할 때 분배하는 방법에 대해서.

1. 모듈러 샤딩 : PK를 모듈러 연산한 결과로 DB를 라우팅하는 방식.

- 레인지 샤딩에 비해 데이터가 균일하게 분산됨
- DB를 추가 증설하는 과정에서 이미지 적재된 데이터의 재정렬이 필요해짐
- 데이터가 일정 수준에서 예상되는 데이터 성격을 가진 곳에 적용할 때 어울림

2. 레인지 샤딩 : PK의 범위를 기준으로 DB를 특정하는 방식

- 모듈러 샤딩에 비해 증설에 재정렬 비용 들지 안흥ㅁ
- 일부 DB에 데이터가 몰릴 수 있다.

3. 디렉토리 샤딩 : 별도의 조회 테이블을 사용해서 샤딩함

- 샤딩에 필요한 시스템이나 알고리즘을 사용할 수 있음
- 샤드를 동적으로 추가하는 것도 비교적 쉬움
- 모든 읽기 및 쓰기 쿼리 전에 조회 테이블을 참조해야하므로 오버헤드가 발생함.
