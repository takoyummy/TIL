# 1. 스프링 웹플럭스가 장점이 될 수 있는 서비스는 어떤 특징이 있을까?

webflux : 비동기 넌블럭킹 형식의 리액티브 프로그래밍 지원.
외부 서버에서 5초 걸리는 것을, 우리 서버에서 기다리지 않음

- 대용량 처리시, 아주 빠른 처리를 할 수 있음
  => mvc였을때, 1:1로 요청을 처리하기 때문에, 트래픽이 몰리면 많은 쓰레드가 생성되고, 이를 전환할때 context switching 비용 발생.
  => 예컨대, 200개의 스레드가 끽해봐야 8개인 코어를 점유하기 위해 경합된다면, 큰 부하 발생.
  => 적절한 스레드의 수를 유지해야함

- Spring Webflux 는 Event단위로 관리되고, 이벤트 큐에 적재되어 순서대로 처리되는 구조.
- Event Loop는 Event Queue에서 Event를 뽑아 하나씩 처리하는 구조
- Spring webflux는 리액터 라이브러리와 넷티를 기반으로 동작함
- 넷티의 경우 스레드 Pool 머신 갯수의 2배

https://pearlluck.tistory.com/712

# 2. 스프링 웹플럭스가 단점이 되는 서비스는 어떤 특징이 있을까?

- Runnable 상태의 스레드가 CPU를 점유하고 있기 때문에, 전반적인 성능하락이 발생함.
- 동영상 인코딩 / 암호화 모듈을 하여 문서를 암호화, 복호화하는 서비스등은 webflux가 적절하지 않음
- 왜? ? ? ?

# 3. 동기 vs 비동기, 블록킹 vs 논블록킹

블록킹 vs 논블록킹

- 블록킹 : 블록킹은 A 함수가 B함수를 호출하면, 제어권을 A가 호출한 B함수에 넘겨주는 것 (B에게 넘겨준 동안, a함수는 실행되지 않고 B함수가 완료되는 시점에 다시 A함수를 실행한다. )
- 논 블록킹 : A함수가 B함수를 호출해도 제어권을 그대로 자신이 가지고 있는 것.

< keyword : 제어할 수 없는 대상의 처리 방법 >

======

동기 VS 비동기

- 동기 : A함수가 B함수를 호출한 뒤, 함수 B의 리턴값을 계속 확인하는 것 + 제어권의 반환과 결과값의 반환하는 타이밍이 같을 때
- 비동기 : 함수 A가 함수B를 호출할때, 콜백함수를 함께 전달하여, B의 작업이 완료되면 함께 실행한 콜백함수를 실행하는 것

함수 A는 B를 호출한 후, B의 작업 완료 여부는 신경쓰지 않는다.

< keyword : 대상들의 시간을 일치시키는가? >

======

- 동기 & 블록킹 : A가 B 함수 호출 => B에게 제어권 넘겨줌(A는 응답을 돌려받을 때까지 멈춤) => B함수 완료 => 제어권 A에게 넘겨줌 => B의 리턴값을 가지고 함수 실행 재개

즉, 순차 실행

- 동기 & 논블록킹 : A 함수측에서 코드를 실행시키며- 중간중간 B에게 완료되었는지 물어봄. 둘 다 실행됨.

즉, 병렬로 수행

=====

- 비동기 & 논블록킹 : A함수는 B함수를 호출하고 ,제어권을 B함수에게 주지 않고, 자신이 계속 가지고 있음. B함수를 호출한 이후에도 멈추지 않고 자신의 코드를 계속 실행시킴.
  B함수를 줄때, 콜백함수를 줘서, B함수는 자신의 작업이 끝나면 A함수가 준 콜백함수를 실행한다.
  => 호출된 함수가 제어권을 가지고 있지 않기 때문에 병렬적으로 수행
- 비동기 & 블록킹 : A함수는 B함수의 리턴값에 신경쓰지 않고, 콜백함수를 보냄(비동기).
  B함수의 작업에 관심 없어하며 A함수는 B함수에게 제어권을 넘김
  A함수는 B함수의 작업이 끝날 때 까지 기다림

논 블록킹일때와 달리 호출된 함수과 제어권을 가지고 있어, 호출된 함수가 완료되기 전까지 다른 작업 진행 불가.

======

쉬운 예 ) https://siyoon210.tistory.com/147

https://www.youtube.com/watch?v=IdpkfygWIMk

https://jh-7.tistory.com/25

# 4. 상속의 장점? 단점?

## 장점

1.  클래스 내부 구현코드를 모두 구현하지 않고, 공통된 로직을 그대로 사용할 수 있다
2.  다형성을 보장한다.

## 단점

1. 설계가 유연하지 않아, 결합도가 높아지면 하나의 기능을 추가하거나 수정하기 위해 불필요하게 많은 클래스들을 수정해야 한다.
2. 자바의 경우 단일 상속을 지원하여, 오히려 중복코드의 양이 늘어날 수 도 있다.
3. 불필요한 기능까지 상속될 수 있다.
4. 부모 클래스의 결합도가 넘어올 수 있다.

https://inpa.tistory.com/entry/OOP-%F0%9F%92%A0-%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5%EC%9D%98-%EC%83%81%EC%86%8D-%EB%AC%B8%EC%A0%9C%EC%A0%90%EA%B3%BC-%ED%95%A9%EC%84%B1Composition-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0

# 5. 스프링에서 Transactional 어노테이션은 내부적으로 어떻게 구현되어있을까?

- 비즈니스 로직이 트랜잭션 처리를 필요로 할 때, 트랜잭션 처리 코드가 비즈니스 로직과 공존하면, 코드 중복이 발생하고, 비즈니스 로직에 집중 또한 힘들어 질 수 있음.
- 이를 위해 만들어진게 @Transactional 어노테이션
- 특정 메서드 또는 클래스가 제공하는 모든 메서드에 대해 내부적으로 AOP 를 통해 트랜잭션 처리코드가 전후로 수행됨
  -> Dynamic Proxy객체에 대신 우이미하여 처리함.
  -> Dynamic Proxy객체는 타깃이 상속하고 있는 인터페이스를 상속 후, 추상메서드를 구현하며 내부적으로 타깃 메서드 호출 전 후로 트랜잭션 처리를 수행함. Controller는 타깃의 메서드를 호출하는 것으로 생각하지만, 실제로는 프록시의 메서드를 호출함.

https://www.youtube.com/watch?v=taAp_u83MwA

프록시 패턴이란 ? :

대상 원본 객체를 대리하여, 대신 처리하게끔 하는 것.

1. Proxy와 실제 Subject를 하나로 묶는 인터페이스 -> 대상 객체와 프록시 역할을 동일하게 하는 추상 메서드 operation()이 정의되어야 함. 인터페이스가 있기에, 클라이언트는 Proxy와 RealSubject역할 차이를 의식할 필요가 없음.
2. 원본 대상 객체
3. Proxy
   가 있어야함.

대상 객체의 메서드를 직접 실행는게 아닌, 대상 객체에 접근하기 전에, Proxy 객체의 메서드를 접근한 후, 추가적인 로직을 처리한 뒤 접근하게 되는 것.
프록시 객체에서, 대상 객체를 composition하여, 해당 객체의 메서드 호출시 동작 앞 뒤에 행위를 추가함.

# 6. RDB와 MongoDB의 차이는?

RDB : 관계형 모델을 기반으로 하는 DB

- 이를 유지하고 관리하기 위한 시스템을 RDBMS 라 함
- 테이블 형식의 데이터 모델을 사용하며, 데이터를 정해진 구조와 스키마에 따라 저장함.
- 데이터는 정해진 열에 저장됨
- 정적인 스키마 사용, 데이터 구조가 변경되거나 업데이트하려면 스키마 수정해야함.
- 외래키 사용 가능, 테이블간 조인 허용

NOSQL :

- 다양한 데이터 모델 제공함
- 키 - 값
- 열 지향 및 그래프 모델 포함
- 구조적 유연성을 제공하며, 데이터를 다른 방식으로 저장할 수 있도록 함
- 테이블 간 관계가 없어, 일반적으로 테이블 간 Join도 불가능함
- Sacle-Out 에 특화되어있음
  ex) Redis, DynamoDB, MongoDB

# 7. Checked Exception vs UnChecked Exception에 대해서

- CheckedException은 RuntimeException의 하위 클래스가 아니면서, Exception클래스의 하위 클래스임. try, catch 혹은 throw로 예외처리해야하는 특징을 지님.
  ex) FileNotFoundException, ClassNotFoundExceptions, IOException, SQLException

  => 예외발생시, checkedException은 roll-back하지 않음

- UncheckedException은 RuntimeException의 하위 클래스면서, 실행중에 발생할 수 있는 예외. 예외처리를 강제하지 않음.
  ex) ArrayIndexOutOfBoundsException, NullPointerException

  => 예외 발생시, uncheckedExctpion은 roll-back함

# 8. 트랜잭션과 커넥션은 어떤 관계가 있을까?

- 트랜잭션 범위는 커넥션을 따라감.
  => 트랙잭션의 범위는 커넥션 기준임.

# 9. AOP란 무엇인지 설명해주세요.

- 핵심 기능 코드에 존재하는 공통된 부가기능 코드를 독립적으로 분리해주는 기술.
- 부가기능 : Advice
- 타킷 : PointCut
  -> 어드바이스, 포인트 컷을 통틀어 어드바이저라고 부름
  -> 어드바이저는 아주 단순한 형태의 aspect
  -> Ascpect는 핵심 기능에 부가되는 특별한 모듈을 뜻하며, 이 에스펙트를 통해 애플리케이션을 설계하여 부가기능을 분리하며 개발하는 방법을 관점지향 프로그래밍이라고 부른다.

=> OOP를 보조하는 기술

AOP는 보통 두 가지 방식이 있음

1. JDK Dynamic Proxy
2. CGLib방식 => 리플랙션 대신 바이트 코드 생성 및 프레임워크를 사용하여, 런타임 시점에 프록시 객체를 만드는 방식임.
   (인터페이스 상속 대신 타깃 오브젝트를 상속하는 프록시 객체인듯)

# 10. AOP를 사용해본적 있으신지?

- @Transactional 어노테이션 사용

# 11. Spring AOP와 AspectJ의 차이에 대해서

- AOP 기술의 원조 프레임 워크인 AspectJ가 있음.
- 프록시처럼 간접적인 방법이 아닌, 컴파일 시점에 컴파일된 타깃 클래스 파일 자체를 수정하거나, 클래스가 JVM에 로딩되는 시점을 가로채서 바이트코드를 수정하여 부가기능이 비즈니스로직과 같이 있는 것처럼 만들어버림.

=> AspectJ 장점 :

1. Spring컨테이너의 DI의 도움을 받아, 다이나믹 프록시 객체를 생성하지 않아도 되므로 스프링과 같은 컨테이너가 없는 환경에서도 적용 가능.
2.

=> AspectJ 단점 :

1. 고급 AOP기술은 바이트 코드 조작을 위해 JVM실행 옵션 변경해야하고, 별도의 바이트 코드 컴파일러를 사용해야하는등 번거로운 작업이 뒤 따름. 따라서 일반적인 다이나믹 프록시 방식의 스프링 AOP로도 충분함.

# 12. 쿼리 작동 시 Insert보다 Update에 더 큰 비용이 드는 이유는 무엇일까?

1. 데이터 이동 : Update쿼리는 이미 존재하는 레코드를 업데이트 하는 작업으로 , 디비 내에서 해당 레코드를 찾고 수정해야함. 이 작업은 데이터를 읽어서 다시 쓰는 과정을 포함하므로 데이터 이동이 필요함

2. update쿼리는 데이터 변경을 로그에 남기고, 복구 가능한 상태를 유지하기 위한 추가 작업을 수반함.

3. 인덱스 업데이트 : update쿼리는 인덱스도 업데이트 해야함. 데이터의 물리적 순서를 유지할때 필요

4. 데이터 락을 설정하므로, 동시에 여러 사용자가 동시에 수정하는 경우, 락 충돌 발생 가능

5. 테이블이 크거나, update대상 레코드가 많은 경우, update작업은 더 많은 시간과 리소스 필요함.
