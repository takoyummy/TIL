# 1. 스프링 웹플럭스가 장점이 될 수 있는 서비스는 어떤 특징이 있을까?

webflux : 비동기 넌블럭킹 형식의 리액티브 프로그래밍 지원.
외부 서버에서 5초 걸리는 것을, 우리 서버에서 기다리지 않음

- 대용량 처리시, 아주 빠른 처리를 할 수 있음
  => mvc였을때, 1:1로 요청을 처리하기 때문에, 트래픽이 몰리면 많은 쓰레드가 생성되고, 이를 전환할때 context switching 비용 발생.
  => 예컨대, 200개의 스레드가 끽해봐야 8개인 코어를 점유하기 위해 경합된다면, 큰 부하 발생.
  => 적절한 스레드의 수를 유지해야함

- Spring Webflux 는 Event단위로 관리되고, 이벤트 큐에 적재되어 순서대로 처리되는 구조.
- Event Loop는 Event Queue에서 Event를 뽑아 하나씩 처리하는 구조
- Spring webflux는 리액터 라이브러리와 넷티를 기반으로 동작함
- 넷티의 경우 스레드 Pool 머신 갯수의 2배

https://pearlluck.tistory.com/712

# 2. 스프링 웹플럭스가 단점이 되는 서비스는 어떤 특징이 있을까?

- Runnable 상태의 스레드가 CPU를 점유하고 있기 때문에, 전반적인 성능하락이 발생함.
- 동영상 인코딩 / 암호화 모듈을 하여 문서를 암호화, 복호화하는 서비스등은 webflux가 적절하지 않음

# 3. 동기 vs 비동기, 블록킹 vs 논블록킹

블록킹 vs 논블록킹

- 블록킹 : 블록킹은 A 함수가 B함수를 호출하면, 제어권을 A가 호출한 B함수에 넘겨주는 것 (B에게 넘겨준 동안, a함수는 실행되지 않고 B함수가 완료되는 시점에 다시 A함수를 실행한다. )
- 논 블록킹 : A함수가 B함수를 호출해도 제어권을 그대로 자신이 가지고 있는 것.

< keyword : 제어할 수 없는 대상의 처리 방법 >

======

동기 VS 비동기

- 동기 : A함수가 B함수를 호출한 뒤, 함수 B의 리턴값을 계속 확인하는 것 + 제어권의 반환과 결과값의 반환하는 타이밍이 같을 때
- 비동기 : 함수 A가 함수B를 호출할때, 콜백함수를 함께 전달하여, B의 작업이 완료되면 함께 실행한 콜백함수를 실행하는 것

함수 A는 B를 호출한 후, B의 작업 완료 여부는 신경쓰지 않는다.

< keyword : 대상들의 시간을 일치시키는가? >

======

- 동기 & 블록킹 : A가 B 함수 호출 => B에게 제어권 넘겨줌(A는 응답을 돌려받을 때까지 멈춤) => B함수 완료 => 제어권 A에게 넘겨줌 => B의 리턴값을 가지고 함수 실행 재개

즉, 순차 실행

- 동기 & 논블록킹 : A 함수측에서 코드를 실행시키며- 중간중간 B에게 완료되었는지 물어봄. 둘 다 실행됨.

즉, 병렬로 수행

=====

- 비동기 & 논블록킹 : A함수는 B함수를 호출하고 ,제어권을 B함수에게 주지 않고, 자신이 계속 가지고 있음. B함수를 호출한 이후에도 멈추지 않고 자신의 코드를 계속 실행시킴.
  B함수를 줄때, 콜백함수를 줘서, B함수는 자신의 작업이 끝나면 A함수가 준 콜백함수를 실행한다.
  => 호출된 함수가 제어권을 가지고 있지 않기 때문에 병렬적으로 수행
- 비동기 & 블록킹 : A함수는 B함수의 리턴값에 신경쓰지 않고, 콜백함수를 보냄(비동기).
  B함수의 작업에 관심 없어하며 A함수는 B함수에게 제어권을 넘김
  A함수는 B함수의 작업이 끝날 때 까지 기다림

논 블록킹일때와 달리 호출된 함수과 제어권을 가지고 있어, 호출된 함수가 완료되기 전까지 다른 작업 진행 불가.

======

쉬운 예 ) https://siyoon210.tistory.com/147

https://www.youtube.com/watch?v=IdpkfygWIMk

# 4. 상속의 장점? 단점?

## 장점

1.  클래스 내부 구현코드를 모두 구현하지 않고, 공통된 로직을 그대로 사용할 수 있다
2.  다형성을 보장한다.

## 단점

1. 설계가 유연하지 않아, 결합도가 높아지면 하나의 기능을 추가하거나 수정하기 위해 불필요하게 많은 클래스들을 수정해야 한다.
2. 자바의 경우 단일 상속을 지원하여, 오히려 중복코드의 양이 늘어날 수 도 있다.
3. 불필요한 기능까지 상속될 수 있다.
4. 부모 클래스의 결합도가 넘어올 수 있다.

https://inpa.tistory.com/entry/OOP-%F0%9F%92%A0-%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5%EC%9D%98-%EC%83%81%EC%86%8D-%EB%AC%B8%EC%A0%9C%EC%A0%90%EA%B3%BC-%ED%95%A9%EC%84%B1Composition-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0

# 5. 스프링에서 Transactional 어노테이션은 내부적으로 어떻게 구현되어있을까?

# 6. RDB와 MongoDB의 차이는?

# 7. Checked Exception vs UnChecked Exception에 대해서

# 8. 트랜잭션과 커넥션은 어떤 관계가 있을까?

# 9. AOP란 무엇인지 설명해주세요.

# 10. AOP를 사용해본적 있으신지?

# 11. Spring AOP와 AspectJ의 차이에 대해서

# 12. 쿼리 작동 시 Insert보다 Update에 더 큰 비용이 드는 이유는 무엇일까?
