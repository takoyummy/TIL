# Quiz1

# 1.브라우저에서 “https://www.naver.com”을 입력하면 그 뒤부터는 어떤일이 일어나는지 자세히 조사해주세요.

1. 먼저 브라우저가 URL 파싱을 진행합니다. 파싱이란 어떤 프로토콜을 통해 어느 url및 포트에 요청할 것인지 확인하는 작업을 의미합니다.

2. 브라우저에서 자신의 로컬 호스트파일과 캐시에 해당 url이 존재하는지 먼저 확인한 뒤에, 존재하지 않는다면 도메인주소를 IP주소로 변환해주는 DNS서버에 요청하여, IP주소를 받습니다.

3. 받아온 IP주소를 가지고 요청한 서버 PC에 패킷 이동을 할 때 라우터에서 IP주소에 해당하는 컴퓨터가 어디있는지 알기 위해 MAC주소가 필요하게 됩니다. 이때 논리주소인 IP주소를 물리주소인 MAC주소로 변환하기위해 라우터는 네트워크에서 ARP(3계층에서 2계층의 MAC Address로 변환할때 사용하는 IP프로토콜)를 브로드캐스팅합니다. 브로드 캐스팅한 결과 동일한 IP주소를 가지고 있는 노드는 자신의 IP주소와 MAC주소를 응답합니다.

4. MAC주소를 알아내어 통신할 서버에 접근하였으니, 실제 통신하기 위해 TCP소켓 연결을 진행하게 됩니다. 이는 3-WAY-HANDSHAKE 통하여 소켓 연결과정이 진행됩니다.
   TCP 3 way HandShaking의 과정은 다음과 같습니다.

4-1. 클라이언트는 서버에 접속을 요청하는 SYN 패킷을 보냅니다. ex) Seq = 10, SYN

4-2. 서버는 SYN요청을 받고 클라이언트에 요청을 수한다는 ACK 과 Syn flag가 설정된 패킷을 발송합니다.

ex) Seq= 50, Ack= 11(Seq(10)에서 1을 더함), SYN,ACK

4-3. 클라이언트는 서버에게 ACK를 보내고 이후부터 연결이 성공되며 데이터를 주고받을 수 있게 됩니다.

ex) Seq = 11, Ack= 51, ACK

4-4. HTTPS 통신이므로, SSL HandShaking 과정이 추가됩니다. 서버로부터 CA를 받고 클라이언트에서 내장된 CA의 공개키를 이용하여 복호화 하여, secret키를 생성 및 전송하여 서버로부터 신뢰 인증을 받습니다.

5. 통신할 준비가 완료되면, 서버에서 해당하는 요청을 받고 이 요청을 수락할 수 있는지 검사한 후, 서버는 이 요청에 대한 응답을 생성하여 브라우저에 전달합니다.

# 2. REST, RESTful API란 무엇인가요? 자세하게 설명해주세요.

REST는 REpresantational State Transfer의 약자로, HTTP통신에서 어떤 자원에 대한 CRUD요청을 Resource와 Method로 표현하여 특정한 형태로 전달하는 방식입니다.

즉 웹에 존재하는 모든 자원에 고유한 URI를 부여해 활용하여 자원을 정의하고 자원에 대한 주소를 지정하는 방법이며, 이러한 REST 형식을 준수하는 시스템을 RESTful하다고 칭합니다.

REST API는 Resource(자원), Method(행위), Representation(표현)으로 구성됩니다.

- Resource (URI) : 서버는 Unique한 ID를 지니는 Resource를 가지고 있으며, 클라이언트는 이 Resource에 대한 요청을 보냅니다. 이러한 Resource는 URI입니다. ex) Members/1

- Method: 서버에 요청을 보내는 방식으로 GET,POST,PUT,PATCH,DELETE등이 있습니다. CRUD연산중에서 알맞은 Method를 사용하여 서버에 요청을 보냅니다.

-Representation : 클라이언트가 서버로 요청을 보낼때 서버가 응답으로 보내주는 자원의 형태를 Representation 이라고 합니다.

REST의 조건

1. 클라이언트 / 서버 구조

자원을 가지고 있는 서버, 자원을 요청하는 쪽이 클라이언트에 해당합니다. 서버는 API를 제공하고, 클라이언트는 사용자 인증, Context등을 직접 관리하여 역할을 구분함으로써 서로간의 의존성을 줄입니다.

2. Stateless(무상태성)

HTTP는 Stateless프로토콜이므로 REST 또한 무상태성을 지닙니다. 서버는 각각의 요청을 별개의 요청으로 인식하여 처리하며, 클라이언트의 상태를 보관하지 않습니다. 이러한 무상태성은 서버에서 불필요한 정보를 처리하지 않으므로 구현의 난이도와 서버의 부담을 줄여줍니다.

3. 캐시 처리 가능

REST API는 웹 표준 HTTP프로토콜을 사용하므로 웹에서 사용하는 인프라(캐싱 기능)를 그대로 사용 가능합니다.

4. 인터페이스 일관성

Resource에 대한 요청을 공통된 규약으로 정해놓았기 때문에 특정 언어나 기술에 종속받지 않고 어느 플랫폼에서나 요청이 가능합니다.

5. 자체 표현 구조

Method + URI 로 이루어져 있어 어떤 자원에 어떤 행위를 하는지 메세지만 보고도 해당 작업을 이해할 수 있습니다.

6. Layered System(계층 구조)

REST API의 서버는 다중 계층으로 구성되어 있어서 보안, 로드밸런싱, 암호화 계층을 따로 추가하여 유연하게 구조를 변경할 수 있다고 합니다.

=> 이러한 REST 의 특징을 기반으로 API를 구현한 것을 REST API라고 칭합니다.

각 요청의 행위와 URI로 추론이 가능해야합니다.

REST API 의 암묵적인 설계 규칙은 다음과 같습니다.

1. 자원의 행위는 Http Method에 명시하고, URI는 정보의 자원만 표현해야합니다.

2. URI에 동사 사용 금지

3. / 로 계층 표현

4. - 하이픈 사용

5. 소문자만 사용

6. HTTP 응답코드로 클라이언트에게 피드백 해야 합니다.

# 3. GC Garbage Collector란 무엇인지? 자세하게 설명해주세요. GC 튜닝이란게 무엇인지에 대해서도 설명해주세요.

자바에서는 메모리를 GC를 통하여 관리하는데, 이 GC는 특정 메소드 호출 후 수행이 완료되어 필요 없는 객체를 청소하는 역할을 합니다.

이때, GC JVM의 Heap영역을 대상으로 메모리 관리를 담당하게 됩니다.
여기서 Heap영역은 Young, Old, Perm으로 나뉘고 Young영역은 Eden과 2개의 Survivor로 이루어져 있습니다.

일단 메모리에 객체가 생성되면 Eden영역에 객체가 생성되고, 이때 Eden 영역에 데이터가 어느정도 쌓이게 되면 survivor로 옮겨집니다. (Minor GC) 여기서 이 두개의 survivor영역 중 하나는 무조건 비어있어야 합니다. 만약 할당된 survivor 영역이 차면, 비어있는 나머지 하나의 survivor영역으로 객체가 이동하게 됩니다. 이때 더이상 Young영역에 공간이 남지 않으면 객체들은 Old영역으로 이동됩니다.

Old영역에서 데이터가 가득차면 Major GC를 실행합니다. Old 영역에서는 Young영역에서 이동된 오래된 객체들이 남아있으며, 참조되지 않은(Unreachable)객체들은 정리 대상이 됩니다. 또한 Major GC는 Young세대에 비해 더 큰 메모리를 차지하므로 일반적으로 더 많은 시간이 소요됩니다.

위에서 설명한 Minor GC, Major GC를 실행하기 위한 여러가지 방식이 존재합니다.

첫번째로 stop-the-world입니다. stop-the-world는 GC를 실행하기 위헤 JVM이 애플리케이션 실행을 멈추는 것입니다. stop the world 를 실행하면 GC를 실행하는 쓰레드를 제외한 나머지 쓰레드는 모두 작업을 멈추게 됩니다. GC를 완료한 이후에나 중단한 작업을 시작하게 되는 것이지요. GC튜닝은 대부분 이 stop-the-world 시간을 줄이는 것에 주안점을 둔다고 합니다.

두번째로 mark and sweep입니다. mark는 사용되는 메모리와 사용되지 않는 메모리를 식별하는 작업이고, sweep은 mark단계에서 사용되지 않는 식별된 메모리를 해제하는 작업입니다.

즉 stop the world를 통해 스레드를 중단시키고, mark 과정을 통해 사용되는 객체를 식별합니다. 이후 sweep 단계에서 마킹되지 않은 객체들을 제거하게 되는 프로세스입니다.

이러한 GC의 방식에서 제대로 성능이 나오지 않는다면, GC튜닝을 진행해야한다고 합니다.
GC튜닝이란, 성능상 이슈를 일으키기 쉬운 GC에 대해서 최적화를 진행하는 것으로, 핵심은 Stop-the-world 시간이 긴 Major GC를 해결하는 것입니다.

고려사항은 다음과 같습니다.

1. GC 알고리즘 변경
   1-1. Parallel GC : Young영역의 Minor GC를 멀티 쓰레드로 수행. Serial GC(초창기 GC, 싱글 스레드로 처리)에 비해 stop-the-world시간 감소.
   1-2. CMS GC : 어플리케이션의 쓰레드와 GC쓰레드가 동시에 실행됨. stop-the-world 시간 최대한 줄이기 위해 고안되었음.
   1-3. G1 GC : jdk 7버전 이상에서 release된 GC로, 기존의 GC알고리즘은 Heap영역을 물리적으로 고정된 Young, Old 영역으로 나누었지만
   G1 gc는 Region이라는 개념을 새로 도입하여 Eden, Survivor,Old영역을 동적으로 사용하게 됨. 가비지로 가득찬 영역을 빠르게 회수해서 빈 공간을 확보한다고 함.

2. GC 주기 조정

3. 힙 크기 조정 : 옵션을 통해 조절하면, 성능 향상 효과를 가져올 수 있다고 합니다.
   예컨대 Old영역으로 넘어가는 객체의 수를 최소화하기 위해, Young영역의 크기를 잘 조절하여서 Old영역으로 넘어가는 빈도를 줄이는 사항도 고려할 수 있다고 합니다.
