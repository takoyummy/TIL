# 1. JDK 8, 11, 17 이 버전들의 특징은? 왜 사람들(또는 회사들)은 이 버전을 사용할까?

- JDK 8 : 새로운 날짜와 시간 API, 람다와 스트림을 지원한다.
  default Method가 추가되어, 구현 내용도 인터페이스에 포함할 수 있다.
  Option Wrapper 클래스가 추가되어, null이 올 수 있는 값을 감싸서 NPE가 발생하지 않도록 함.

- JDK 11: 람다 인자에 대해 타입 추론 가능이해 짐.
  람다식에 var 키워드 사용 가능하게 되면서, 파라미터 어노테이션 추가됨.
  최신 표준의 Http Client 추가됨.

- JDK 17: Sealed Class가 정식으로 추가됨. Sealed Class와 Interface로 상하거나 구현할 클래스를 저장해두고, 해당 클래스들만 상속 또는 구현을 허용함. Sealed 키워드를 통해 어떤 클래스가 해당 클래스를 상속 or 구현하는지 쉽게 알수 있다. 또한 Record 클래스 추가를 통해 불필요한 코드 제거 및 불편 데이터를 객체간 전달하는 작업을 간단하게 함.

- LTS(Long Term Support) 버전이기 때문에, 타 버전 대비 8년간의 지속적인 보안 업데이트와 버그 수정을 지원 받을 수 있다. 그래서 개발 시에 8, 11, 17만 주로 고려하는 것.

# 2. 컴파일 언어 vs 인터프리터 언어?

- 컴파일 언어 : 소스코드를 기계어로 컴파일해서 실행파일을 만들어 실행하는 방식. 컴파일 언어는 원시코드(프로그래머가 작성한 소스코드)를 한 번에 기계어로 변환하여 실행파일을 만든다. 컴파일 단계와 실행 단계가 분리 되어 있다.
  한번에 모든 코드를 컴파일 하여 실행전에 오류 파악 가능. 코드를 수정하면 다시 컴파일 과정을 겪어야 함.
  종류로 C, C++이 있다.

- 인터프리터 언어 : 코드를 한 줄 씩 내려가며 실행하는 방식. 인터프리터 언어는 소스코드를 기계어로 번역하는 과정 없이 한 줄 씩 해석하여 바로 명령어를 실행한다. 컴파일링 과정이 없고 실행시마다 한 줄씩 인터프리트 해야하기 때문에 비교적 실행 속도가 느리다.

R, Pyhton, Ruby 가 대표적인 인터프리터 언어이다.

여기서 자바는 컴파일러와 인터프리터 언어의 특징을 함께 지님.
JVM(자바 프로그램을 실행하기 위한 가상머신)은 자바소스코드를 컴파일 하여 바이트 코드를 생성하고, 이 바이트 코드를 런타임시에 한 줄씩 인터프리트 함.

# 3. 객체 vs 클래스의 차이?

- 클래스는 객체를 만들기 위한 일종의 템플릿으로, 어떤 객체가 가져야 할 속성과 동작을 정의함.

- 객체는 클래스를 기반으로 실제로 생성된 실체. 속성과 동작을 실제로 가지고 있음.

- 인스턴스는 객체가 메모리에 올라와 있는 상태.

# 4. 인스턴스 변수 vs 클래스 변수?

- 인스턴스 변수는 객체의 속성을 나타내는 변수로, 각각의 객체마다 별도의 인스턴스 변수가 생성되며, 객체가 생성될 때마다 인스턴스 변수의 값은 객체에 고유하게 유지됨. 인스턴스 변수는 객체의 상태를 나타내거나 저장할 때 사용됨.

- 클래스 변수는 클래스 자체에 속하는 변수로, 해당 클래스의 모든 인스턴스에 값을 공유함. static키워드로 사용할 수 있음. 상수나 클래스 전반에 걸쳐 전반적인 데이터를 저장할때 사용.

#5. Primitive type vs reference type?

- 원시 타입은 기본적인 데이터 종류 사용. 정수, 실수, 문자, 논리등의 데이터를 표현할 때 사용. 실제 값을 직접 저장하기 때문에, 해당 값을 직접 메모리에 보유하며 스택메모리에 저장됨.
- 참조타입은 객체의 참조를 나타내는 변수타입, 클래스, 인터페이스, 배열등이 해당. 힙 메모리에 실제 객체가 저장됨. 참조타입의 변수를 다른 변수에 할당할 때 주소가 복사됨. 두 변수는 같은 객체를 가리키게 됨.

=> 꼬리질문 : Wrapper 클래스는 Primitive 타입일까? Reference Type일까?
: Wrapper클래스는 Reference Type으로 원시 데이터 타입을 객체로 감싸기 위해 사용됨. 다만 자바 5부터 Auto Boxing 과 Auto Unboxing이 지원되면서 원시와 클래스간의 변환을 자동으로 처리할 수 있게 되었음.

#6. 디스크와 메모리의 차이?

- 디스크 : 비휘발성. 전원이 꺼져도 데이터 보존. 메모리에 비해 대용량 데이터 저장 가능. 회전하는 원판을 사용하므로 메모리에 비해 상대적으로 느림.
- 메모리 : 휘발성. 데이터가 주소에 바로 액세스됨. 빠른 읽기 / 쓰기 속도 지님.

#7. String 리터럴과 new String의 선언 방법의 차이는?

- String 리터럴은 문자열을 직접 할당하며, 내부적으로 String Pool에 해당 문자열을 저장. 이미 존재하는 문자열 리터럴과 동일한 내용의 문자열을 참조함. 동일한 리터럴 문자열이 여러번 사용되면 메모리 공간 절약 가능.
- new String은 새로운 String 객체를 생성하여, 문자열 리터럴을 인수로 전달하여 새로운 객체를 생성함. 이 방식으로 생성된 String 객체는 Heap 메모리에 저장됨. 새로운 객체가 생성되기 때문에, 동일한 내용을 가진 문자열이라도 메모리에 중복으로 저장될 수 있다.

#8. Double vs Float, Bigdecimal을 쓰는 이유?

- Double은 64비트 사용, Float은 32비트 사용. Double은 Float보다 두 배의 메모리 사용. 이는 Double이 더 높은 정밀도 가짐. float은 보통 메모리 사용을 줄이고 싶을때 사용.
  BigDecimal은 정확한 소수연산을 위해 사용되는 클래스로, 부동 소수점 연산시에 발생할 수 있는 반올림 오차나 정밀도 손실을 피할 수 있도록 고정된 크기의 소수점을 다룸. 금융 애플리케이션, 세금계산, 정확한 계산이 필요할 때 보통 BigDecimal 많이 사용. 메모리 사용과 연산 속도가 더 높을 수 있다.

#9. 타입 프로모션과 타입 캐스팅은 무엇인가?

- 타입 프로모션 : 작은 데이터 타입에서 큰 데이터 타입으로 자동 변환되는 것을 말함. 자동 현변환이라고 함. 숫자 타입간에 발생하며, 컴파일러에 의해 처리됨. 데이터 손실 없이 데이터 확장.

- 타입 캐스팅(명시적 형변환) : 데이터 타입을 프로그래머가 수동으로 변환. 큰 데이터 타입을 작은 데이터 타입으로 변환할 때, 데이터 손실이 발생할 수 있으므로 프로그래머가 캐스팅을 명시적으로 수행.
